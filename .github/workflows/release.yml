name: release

on:
  push:
    tags: ["v*"]

permissions:
  contents: write
  actions: read

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  github-release:
    runs-on: ubuntu-latest
    steps:
      - name: Wait for build workflow
        id: wait_build
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const workflow_id = "build.yml";

            const tag = context.ref.replace("refs/tags/", "");
            const expectedSha = context.sha;

            const pollIntervalMs = 15 * 1000;
            const maxAttempts = 120;

            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
              const { data } = await github.rest.actions.listWorkflowRuns({
                owner,
                repo,
                workflow_id,
                per_page: 20,
              });

              const runs = data.workflow_runs || [];
              const matchingRuns = runs.filter((run) => {
                return (
                  run.event === "push" &&
                  run.head_branch === tag &&
                  run.head_sha === expectedSha
                );
              });

              if (matchingRuns.length === 0) {
                core.info(
                  `No matching build.yml run yet for ${tag}@${expectedSha} (attempt ${attempt}/${maxAttempts})`,
                );
              } else {
                const run = matchingRuns[0];
                core.info(
                  `Found build.yml run ${run.id} (status=${run.status}, conclusion=${run.conclusion})`,
                );

                if (run.status === "completed") {
                  if (run.conclusion !== "success") {
                    throw new Error(
                      `build.yml run ${run.id} completed with conclusion=${run.conclusion}`,
                    );
                  }

                  core.setOutput("run_id", String(run.id));
                  return;
                }
              }

              await new Promise((resolve) => setTimeout(resolve, pollIntervalMs));
            }

            throw new Error(
              `Timed out waiting for build.yml to complete for ${tag}@${expectedSha}`,
            );

      - name: Download helm-chart artifact
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v7.0.0
        with:
          name: helm-chart
          path: .
          github-token: ${{ github.token }}
          repository: ${{ github.repository }}
          run-id: ${{ steps.wait_build.outputs.run_id }}
          merge-multiple: true

      - name: Prepare chart files
        shell: bash
        run: |
          set -euo pipefail
          shopt -s nullglob

          # The build workflow uploads `dist/*.tgz` and `dist/*.spdx.json`, but the
          # artifact payload is flattened to the file basenames when downloaded.
          # Normalize into `dist/` so the release upload globs are stable.
          if compgen -G "dist/*.tgz" >/dev/null && compgen -G "dist/*.spdx.json" >/dev/null; then
            echo "Found chart artifacts in dist/."
          else
            mkdir -p dist

            tgz_files=( *.tgz )
            sbom_files=( *.spdx.json )

            if [ ${#tgz_files[@]} -eq 0 ] || [ ${#sbom_files[@]} -eq 0 ]; then
              echo "Expected chart artifacts not found in workspace:"
              ls -la
              exit 1
            fi

            mv -f *.tgz dist/
            mv -f *.spdx.json dist/
          fi

          ls -la dist
          ls -1 dist/*.tgz >/dev/null
          ls -1 dist/*.spdx.json >/dev/null

      - name: Generate release body
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8
        with:
          script: |
            const fs = require("fs");

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const tag = context.ref.replace("refs/tags/", "");

            const pagesUrl = `https://${owner}.github.io/${repo}`;
            const image = `ghcr.io/${owner}/gpubox:${tag}`;

            const { data } = await github.rest.repos.generateReleaseNotes({
              owner,
              repo,
              tag_name: tag,
            });

            const notes = (data && data.body ? data.body : "").trim();

            const bodyLines = [
              "## Install",
              "",
              "Helm chart repo (GitHub Pages):",
              "",
              "```bash",
              `helm repo add gpubox ${pagesUrl}`,
              "helm repo update",
              "",
              "helm upgrade --install gpubox gpubox/gpubox \\",
              "  --namespace gpubox \\",
              "  --create-namespace",
              "```",
              "",
              "Container image:",
              "",
              `\`${image}\``,
              "",
              "## Release notes",
              "",
              notes,
              "",
            ];

            const body = bodyLines.join("\n");

            fs.writeFileSync("release-body.md", body, { encoding: "utf8" });
            core.info("Wrote release-body.md");

      - name: Create GitHub Release
        uses: ncipollo/release-action@b7eabc95ff50cbeeedec83973935c8f306dfcd0b # v1.20.0
        with:
          tag: ${{ github.ref_name }}
          name: ${{ github.ref_name }}
          bodyFile: release-body.md
          artifacts: "dist/*.tgz,dist/*.spdx.json"
          allowUpdates: true
          artifactErrorsFailBuild: true
